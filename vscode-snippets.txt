{
       // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
       // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
       // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
       // same ids are connected.
       // Example:
       "FenwickTree": {
              "prefix": "fenwick",
              "body": [
                     "struct fenwick",
                     "{",
                     "      int bit[N];",
                     "      fenwick()",
                     "      {",
                     "             memset(bit, 0, sizeof bit);",
                     "      }",
                     "      void add(int x, int v)",
                     "      {",
                     "             for (; x < N; x += x & -x)",
                     "                    bit[x] += v;",
                     "      }",
                     "      int upto(int x)",
                     "      {",
                     "             int ret = 0;",
                     "             for (; x; x -= x & -x)",
                     "                    ret += bit[x];",
                     "             return ret;",
                     "      }",
                     "      inline int get(int l, int r) { return upto(r) - upto(l - 1); }",
                     "};"
              ],
              "description": "binary indexed tree (aka fenwick tree)"
       },
       "PairSegTree": {
              "prefix": "pairsegtree",
              "body": [
                     "pair<int, int> tree[4 * N];",
                     "void update(int ix, pair<int, int> val, int node = 1, int L = 0, int R = N - 1)",
                     "{",
                     "       if (L == R)",
                     "             return void(tree[node] = val);",
                     "       int mid = (L + R) >> 1;",
                     "       if (ix <= mid)",
                     "             update(ix, val, node * 2, L, mid);",
                     "       else",
                     "             update(ix, val, node * 2 + 1, mid + 1, R);",
                     "       tree[node] = max(tree[node * 2], tree[node * 2 + 1]);",
                     "}",
                     "pair<int, int> query(int l, int r, int node = 1, int L = 0, int R = N - 1)",
                     "{",
                     "      if (l > r || l > R || r < L)",
                     "             return {0, 0};",
                     "      if (L >= l && R <= r)",
                     "             return tree[node];",
                     "      int mid = (L + R) >> 1;",
                     "      return max(query(l, r, node * 2, L, mid), query(l, r, node * 2 + 1, mid + 1, R));",
                     "}",
              ],
              "description": "binary indexed tree (aka fenwick tree)"
       },
       "ModOperations": {
              "prefix": "modo",
              "body": [
                     "ll add(ll x, ll y) { return (x + y) % mod; }",
                     "ll mul(ll x, ll y) { return 1ll * x * y % mod; }",
              ],
              "description": "some useful mod operations"
       },
       "Union-Find": {
              "prefix": "dsu",
              "body": [
                     "struct dsu",
                     "{",
                     "      int fat[N];",
                     "      dsu()",
                     "      {",
                     "             iota(fat, fat + N, 0);",
                     "      }",
                     "      int find(int x) { return fat[x] = (x == fat[x] ? x : find(fat[x])); }",
                     "      void link(int u, int v)",
                     "      {",
                     "             u = find(u), v = find(v);",
                     "             fat[u] = v;",
                     "      }",
                     "      bool same(int u, int v)",
                     "      {",
                     "             return find(u) == find(v);",
                     "      }",
                     "};      ",
              ],
              "description": "union find data structure"
       },
       "Range-Set-SegTree": {
              "prefix": "rangeSet",
              "body": [
                     "struct rangeSet",
                     "{",
                     "      int tree[4 * N];",
                     "      int lazy[4 * N];",
                     "      int sen = -1;",
                     "      rangeSet() { memset(tree, 0, sizeof tree), memset(lazy, -1, sizeof lazy); }",
                     "      void pull(int node) { tree[node] = tree[node * 2] + tree[node * 2 + 1]; }",
                     "      void push(int node, int L, int R)",
                     "      {",
                     "             if (lazy[node] != sen)",
                     "             {",
                     "                    tree[node] = (R - L + 1) * lazy[node];",
                     "                    if (L != R)",
                     "                    lazy[node * 2] = lazy[node * 2 + 1] = lazy[node];",
                     "                    lazy[node] = sen;",
                     "             }",
                     "      }",
                     "      void update(int l, int r, int v, int node = 1, int L = 0, int R = N - 1)",
                     "      {",
                     "             push(node, L, R);",
                     "             if (l > R || r < L)",
                     "                    return;",
                     "             if (L >= l && R <= r)",
                     "             {",
                     "                    lazy[node] = v;",
                     "                    push(node, L, R);",
                     "                    return;",
                     "             }",
                     "             int mid = (L + R) >> 1;",
                     "             update(l, r, v, node * 2, L, mid);",
                     "             update(l, r, v, node * 2 + 1, mid + 1, R);",
                     "             pull(node);",
                     "      }",
                     "      int query(int l, int r, int node = 1, int L = 0, int R = N - 1)",
                     "      {",
                     "             if (l > r || l > R || r < L)",
                     "                    return 0;",
                     "             push(node, L, R);",
                     "             if (L >= l && R <= r)",
                     "                   return tree[node];",
                     "             int mid = (L + R) >> 1;",
                     "             return query(l, r, node * 2, L, mid) + query(l, r, node * 2 + 1, mid + 1, R);",
                     "      }",
                     "};",
              ],
              "description": "Range Set Segment Tree"
       },
       "Fast power mod": {
              "prefix": "faspow",
              "body": [
                     "ll faspow(ll x, ll y, ll MOD = mod)",
                     "{",
                     "       ll ret = 1ll;",
                     "       while (y)",
                     "       {",
                     "              if (y & 1)",
                     "                     ret = 1ll * ret * x % MOD;",
                     "              x = 1ll * x * x % MOD;",
                     "              y >>= 1ll;",
                     "       }",
                     "       return ret;",
                     "}",
              ],
              "description": "Fast Power"
       },
       "Mod Inverse": {
              "prefix": "inv",
              "body": [
                     "ll inv(ll x) { return faspow(x, mod - 2); }",
              ],
              "description": "Mod Inverse"
       },
       "nCr": {
              "prefix": "ncr",
              "body": [
                     "ll ncr(ll x, ll y) { return 1ll * fact[x] * inv(fact[y]) % mod * inv(fact[x - y]) % mod; }",
              ],
              "description": "n choose r"
       },
       "Fraction": {
              "prefix": "fraction",
              "body": [
                     "template <class T>",
                     "struct fraction",
                     "{",
                     "       T gcd(T a, T b) { return b == T(0) ? a : gcd(b, a % b); }",
                     "       T n, d;",
                     "       fraction(T n_ = T(0), T d_ = T(1))",
                     "       {",
                     "              assert(d_ != 0);",
                     "              n = n_, d = d_;",
                     "              if (d < T(0))",
                     "                     n = -n, d = -d;",
                     "              T g = gcd(abs(n), abs(d));",
                     "              n /= g, d /= g;",
                     "       }",
                     "       fraction(const fraction<T> &other) : n(other.n), d(other.d) {}",
                     "       fraction<T> operator+(const fraction<T> &other) const { return fraction<T>(n * other.d + other.n * d, d * other.d); }",
                     "       fraction<T> operator-(const fraction<T> &other) const { return fraction<T>(n * other.d - other.n * d, d * other.d); }",
                     "       fraction<T> operator*(const fraction<T> &other) const { return fraction<T>(n * other.n, d * other.d); }",
                     "       fraction<T> operator/(const fraction<T> &other) const { return fraction<T>(n * other.d, d * other.n); }",
                     "       bool operator<(const fraction<T> &other) const { return n * other.d < other.n * d; }",
                     "       bool operator<=(const fraction<T> &other) const { return !(other < *this); }",
                     "       bool operator>(const fraction<T> &other) const { return other < *this; }",
                     "       bool operator>=(const fraction<T> &other) const { return !(*this < other); }",
                     "       bool operator==(const fraction<T> &other) const { return n == other.n && d == other.d; }",
                     "       bool operator!=(const fraction<T> &other) const { return !(*this == other); }",
                     "       void print() { cout << '(' << n << '/' << d << ')'; }",
                     "};",
              ],
              "description": "struct fration with simple arithmetic operations."
       },
       "segtree": {
              "prefix": "segtree",
              "body": [
                     "template <class T>",
                     "struct segtree",
                     "{",
                     "       T tree[4 * N];",
                     "       T eval(T x, T y) { return min(x, y); }",
                     "       void update(int ix, T val, int node = 1, int L = 0, int R = N - 1)",
                     "       {",
                     "              if (L == R)",
                     "                     return void(tree[node] = val);",
                     "              int mid = (L + R) >> 1;",
                     "              if (ix <= mid)",
                     "                     update(ix, val, node * 2, L, mid);",
                     "              else",
                     "                     update(ix, val, node * 2 + 1, mid + 1, R);",
                     "              tree[node] = eval(tree[node * 2], tree[node * 2 + 1]);",
                     "       }",
                     "       T query(int l, int r, int node = 1, int L = 0, int R = N - 1)",
                     "       {",
                     "              if (l > r || l > R || r < L)",
                     "                     return 1e9;",
                     "              if (L >= l && R <= r)",
                     "                     return tree[node];",
                     "              int mid = (L + R) >> 1;",
                     "              return eval(query(l, r, node * 2, L, mid), query(l, r, node * 2 + 1, mid + 1, R));",
                     "       }",
                     "};",
              ],
              "description": "basic struct segment tree."
       },
       "miller-rabin": {
              "prefix": "miller",
              "body": [
                     "bool miller(ll n, int k = 40)",
                     "{",
                     "       if (n <= 3)",
                     "              return n > 1;",
                     "       int s = 0;",
                     "       ll d = n - 1;",
                     "       while (~d & 1)",
                     "              d >>= 1, s++;",
                     "",
                     "       auto modpow = [&](ll x, ll y, ll MOD = mod) -> ll {",
                     "              ll ret = 1ll;",
                     "              while (y)",
                     "              {",
                     "                     if (y & 1)",
                     "                            ret = 1ll * ret * x % MOD;",
                     "                     x = 1ll * x * x % MOD;",
                     "                     y >>= 1ll;",
                     "              }",
                     "              return ret;",
                     "       };",
                     "       while (k--)",
                     "       {",
                     "              ll a = (n - 3) * rand() / RAND_MAX + 2;",
                     "              ll x = modpow(a, d, n);",
                     "              if (x == 1 || x == n - 1)",
                     "                     continue;",
                     "              bool ok = false;",
                     "              for (int i = 0; i < s - 1; ++i)",
                     "              {",
                     "                     x = (x * x) % n;",
                     "                     if (x == 1)",
                     "                            return false;",
                     "                     if (x == n - 1)",
                     "                     {",
                     "                            ok = true;",
                     "                            break;",
                     "                     }",
                     "              }",
                     "              if (!ok)",
                     "                     return false;",
                     "       }",
                     "       return true;",
                     "}",
              ],
              "description": "probablistic test for compositeness."
       }
}
