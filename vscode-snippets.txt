{
       // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
       // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
       // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
       // same ids are connected.
       // Example:
       "FenwickTree": {
              "prefix": "fenwick",
              "body": [
                     "struct fenwick",
                     "{",
                     "      int bit[N];",
                     "      fenwick()",
                     "      {",
                     "             memset(bit, 0, sizeof bit);",
                     "      }",
                     "      void add(int x, int v)",
                     "      {",
                     "             for (; x < N; x += x & -x)",
                     "                    bit[x] += v;",
                     "      }",
                     "      int upto(int x)",
                     "      {",
                     "             int ret = 0;",
                     "             for (; x; x -= x & -x)",
                     "                    ret += bit[x];",
                     "             return ret;",
                     "      }",
                     "      inline int get(int l, int r) { return upto(r) - upto(l - 1); }",
                     "};"
              ],
              "description": "binary indexed tree (aka fenwick tree)"
       },
       "PairSegTree": {
              "prefix": "pairsegtree",
              "body": [
                     "pair<int, int> tree[4 * N];",
                     "void update(int ix, pair<int, int> val, int node = 1, int L = 0, int R = N - 1)",
                     "{",
                     "       if (L == R)",
                     "             return void(tree[node] = val);",
                     "       int mid = (L + R) >> 1;",
                     "       if (ix <= mid)",
                     "             update(ix, val, node * 2, L, mid);",
                     "       else",
                     "             update(ix, val, node * 2 + 1, mid + 1, R);",
                     "       tree[node] = max(tree[node * 2], tree[node * 2 + 1]);",
                     "}",
                     "pair<int, int> query(int l, int r, int node = 1, int L = 0, int R = N - 1)",
                     "{",
                     "      if (l > r || l > R || r < L)",
                     "             return {0, 0};",
                     "      if (L >= l && R <= r)",
                     "             return tree[node];",
                     "      int mid = (L + R) >> 1;",
                     "      return max(query(l, r, node * 2, L, mid), query(l, r, node * 2 + 1, mid + 1, R));",
                     "}",
              ],
              "description": "binary indexed tree (aka fenwick tree)"
       },
       "ModOperations": {
              "prefix": "modo",
              "body": [
                     "ll add(ll x, ll y) { return (x + y) % mod; }",
                     "ll mul(ll x, ll y) { return 1ll * x * y % mod; }",
              ],
              "description": "some useful mod operations"
       },
       "Union-Find": {
              "prefix": "dsu",
              "body": [
                     "struct dsu,",
                     "{",
                     "      int fat[N];",
                     "      dsu()",
                     "      {",
                     "             iota(fat, fat + N, 0);",
                     "      }",
                     "      int find(int x) { return fat[x] = (x == fat[x] ? x : find(fat[x])); }",
                     "      void link(int u, int v)",
                     "      {",
                     "             u = find(u), v = find(v);",
                     "             fat[u] = v;",
                     "      }",
                     "      bool same(int u, int v)",
                     "      {",
                     "             return find(u) == find(v);",
                     "      }",
                     "};      ",
              ],
              "description": "union find data structure"
       },
       "Range-Set-SegTree": {
              "prefix": "rangeSet",
              "body": [
                     "struct rangeSet",
                     "{",
                     "      int tree[4 * N];",
                     "      int lazy[4 * N];",
                     "      int sen = -1;",
                     "      rangeSet() { memset(tree, 0, sizeof tree), memset(lazy, -1, sizeof lazy); }",
                     "      void pull(int node) { tree[node] = tree[node * 2] + tree[node * 2 + 1]; }",
                     "      void push(int node, int L, int R)",
                     "      {",
                     "             if (lazy[node] != sen)",
                     "             {",
                     "                    tree[node] = (R - L + 1) * lazy[node];",
                     "                    if (L != R)",
                     "                    lazy[node * 2] = lazy[node * 2 + 1] = lazy[node];",
                     "                    lazy[node] = sen;",
                     "             }",
                     "      }",
                     "      void update(int l, int r, int v, int node = 1, int L = 0, int R = N - 1)",
                     "      {",
                     "             push(node, L, R);",
                     "             if (l > R || r < L)",
                     "                    return;",
                     "             if (L >= l && R <= r)",
                     "             {",
                     "                    lazy[node] = v;",
                     "                    push(node, L, R);",
                     "                    return;",
                     "             }",
                     "             int mid = (L + R) >> 1;",
                     "             update(l, r, v, node * 2, L, mid);",
                     "             update(l, r, v, node * 2 + 1, mid + 1, R);",
                     "             pull(node);",
                     "      }",
                     "      int query(int l, int r, int node = 1, int L = 0, int R = N - 1)",
                     "      {",
                     "             if (l > r || l > R || r < L)",
                     "                    return 0;",
                     "             push(node, L, R);",
                     "             if (L >= l && R <= r)",
                     "                   return tree[node];",
                     "             int mid = (L + R) >> 1;",
                     "             return query(l, r, node * 2, L, mid) + query(l, r, node * 2 + 1, mid + 1, R);",
                     "      }",
                     "};",
              ],
              "description": "Range Set Segment Tree"
       }
}
